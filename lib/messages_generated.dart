// Autogenerated from Pigeon (v0.1.23), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators
// @dart = 2.8
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/services.dart';

class ExtendTimeResponse {
  String timerId;
  int additionalTime;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    pigeonMap['additionalTime'] = additionalTime;
    return pigeonMap;
  }

  static ExtendTimeResponse decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return ExtendTimeResponse()
      ..timerId = pigeonMap['timerId'] as String
      ..additionalTime = pigeonMap['additionalTime'] as int;
  }
}

class CountDownRequest {
  String timerId;
  int newTime;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    pigeonMap['newTime'] = newTime;
    return pigeonMap;
  }

  static CountDownRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return CountDownRequest()
      ..timerId = pigeonMap['timerId'] as String
      ..newTime = pigeonMap['newTime'] as int;
  }
}

class TimerRequest {
  String timerId;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    return pigeonMap;
  }

  static TimerRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return TimerRequest()
      ..timerId = pigeonMap['timerId'] as String;
  }
}

class OpenRequest {
  String timerId;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    return pigeonMap;
  }

  static OpenRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return OpenRequest()
      ..timerId = pigeonMap['timerId'] as String;
  }
}

class WidgetUpdateResponse {
  String title;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['title'] = title;
    return pigeonMap;
  }

  static WidgetUpdateResponse decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return WidgetUpdateResponse()
      ..title = pigeonMap['title'] as String;
  }
}

class InitializationRequest {
  int callbackHandle;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['callbackHandle'] = callbackHandle;
    return pigeonMap;
  }

  static InitializationRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return InitializationRequest()
      ..callbackHandle = pigeonMap['callbackHandle'] as int;
  }
}

class NotificationResponse {
  String timerId;
  bool success;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    pigeonMap['success'] = success;
    return pigeonMap;
  }

  static NotificationResponse decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return NotificationResponse()
      ..timerId = pigeonMap['timerId'] as String
      ..success = pigeonMap['success'] as bool;
  }
}

class RunningNotificationRequest {
  String description;
  String timerId;
  String title;
  int accentColor;
  String restartAction;
  String continueAction;
  String pauseAction;
  String cancelAction;
  List<Object> extendActions;
  int duration;
  int remainingTime;
  bool shakeToExtend;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['description'] = description;
    pigeonMap['timerId'] = timerId;
    pigeonMap['title'] = title;
    pigeonMap['accentColor'] = accentColor;
    pigeonMap['restartAction'] = restartAction;
    pigeonMap['continueAction'] = continueAction;
    pigeonMap['pauseAction'] = pauseAction;
    pigeonMap['cancelAction'] = cancelAction;
    pigeonMap['extendActions'] = extendActions;
    pigeonMap['duration'] = duration;
    pigeonMap['remainingTime'] = remainingTime;
    pigeonMap['shakeToExtend'] = shakeToExtend;
    return pigeonMap;
  }

  static RunningNotificationRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return RunningNotificationRequest()
      ..description = pigeonMap['description'] as String
      ..timerId = pigeonMap['timerId'] as String
      ..title = pigeonMap['title'] as String
      ..accentColor = pigeonMap['accentColor'] as int
      ..restartAction = pigeonMap['restartAction'] as String
      ..continueAction = pigeonMap['continueAction'] as String
      ..pauseAction = pigeonMap['pauseAction'] as String
      ..cancelAction = pigeonMap['cancelAction'] as String
      ..extendActions = pigeonMap['extendActions'] as List<Object>
      ..duration = pigeonMap['duration'] as int
      ..remainingTime = pigeonMap['remainingTime'] as int
      ..shakeToExtend = pigeonMap['shakeToExtend'] as bool;
  }
}

class TimeNotificationRequest {
  String description;
  String timerId;
  String title;
  int accentColor;
  String restartAction;
  String continueAction;
  String pauseAction;
  String cancelAction;
  List<Object> extendActions;
  int duration;
  int remainingTime;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['description'] = description;
    pigeonMap['timerId'] = timerId;
    pigeonMap['title'] = title;
    pigeonMap['accentColor'] = accentColor;
    pigeonMap['restartAction'] = restartAction;
    pigeonMap['continueAction'] = continueAction;
    pigeonMap['pauseAction'] = pauseAction;
    pigeonMap['cancelAction'] = cancelAction;
    pigeonMap['extendActions'] = extendActions;
    pigeonMap['duration'] = duration;
    pigeonMap['remainingTime'] = remainingTime;
    return pigeonMap;
  }

  static TimeNotificationRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return TimeNotificationRequest()
      ..description = pigeonMap['description'] as String
      ..timerId = pigeonMap['timerId'] as String
      ..title = pigeonMap['title'] as String
      ..accentColor = pigeonMap['accentColor'] as int
      ..restartAction = pigeonMap['restartAction'] as String
      ..continueAction = pigeonMap['continueAction'] as String
      ..pauseAction = pigeonMap['pauseAction'] as String
      ..cancelAction = pigeonMap['cancelAction'] as String
      ..extendActions = pigeonMap['extendActions'] as List<Object>
      ..duration = pigeonMap['duration'] as int
      ..remainingTime = pigeonMap['remainingTime'] as int;
  }
}

class NotificationRequest {
  String timerId;
  String title;
  String description;
  int accentColor;
  String restartAction;
  String continueAction;
  String pauseAction;
  String cancelAction;
  List<Object> extendActions;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    pigeonMap['title'] = title;
    pigeonMap['description'] = description;
    pigeonMap['accentColor'] = accentColor;
    pigeonMap['restartAction'] = restartAction;
    pigeonMap['continueAction'] = continueAction;
    pigeonMap['pauseAction'] = pauseAction;
    pigeonMap['cancelAction'] = cancelAction;
    pigeonMap['extendActions'] = extendActions;
    return pigeonMap;
  }

  static NotificationRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return NotificationRequest()
      ..timerId = pigeonMap['timerId'] as String
      ..title = pigeonMap['title'] as String
      ..description = pigeonMap['description'] as String
      ..accentColor = pigeonMap['accentColor'] as int
      ..restartAction = pigeonMap['restartAction'] as String
      ..continueAction = pigeonMap['continueAction'] as String
      ..pauseAction = pigeonMap['pauseAction'] as String
      ..cancelAction = pigeonMap['cancelAction'] as String
      ..extendActions = pigeonMap['extendActions'] as List<Object>;
  }
}

class CancelResponse {
  String timerId;
  bool success;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    pigeonMap['success'] = success;
    return pigeonMap;
  }

  static CancelResponse decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return CancelResponse()
      ..timerId = pigeonMap['timerId'] as String
      ..success = pigeonMap['success'] as bool;
  }
}

class CancelRequest {
  String timerId;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['timerId'] = timerId;
    return pigeonMap;
  }

  static CancelRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return CancelRequest()
      ..timerId = pigeonMap['timerId'] as String;
  }
}

class InstalledAppsResponse {
  List<Object> apps;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['apps'] = apps;
    return pigeonMap;
  }

  static InstalledAppsResponse decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return InstalledAppsResponse()
      ..apps = pigeonMap['apps'] as List<Object>;
  }
}

class LaunchAppRequest {
  String packageName;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['packageName'] = packageName;
    return pigeonMap;
  }

  static LaunchAppRequest decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return LaunchAppRequest()
      ..packageName = pigeonMap['packageName'] as String;
  }
}

class Package {
  String title;
  String icon;
  String packageName;

  Object encode() {
    final Map<Object, Object> pigeonMap = <Object, Object>{};
    pigeonMap['title'] = title;
    pigeonMap['icon'] = icon;
    pigeonMap['packageName'] = packageName;
    return pigeonMap;
  }

  static Package decode(Object message) {
    final Map<Object, Object> pigeonMap = message as Map<Object, Object>;
    return Package()
      ..title = pigeonMap['title'] as String
      ..icon = pigeonMap['icon'] as String
      ..packageName = pigeonMap['packageName'] as String;
  }
}

abstract class FlutterTimerApi {
  void onExtendTime(ExtendTimeResponse arg);
  void onCountDown(CountDownRequest arg);
  void onContinueRequest(TimerRequest arg);
  void onPauseRequest(TimerRequest arg);
  void onCancelRequest(TimerRequest arg);
  void onRestartRequest(TimerRequest arg);
  void onOpen(OpenRequest arg);
  void onAlarm(TimerRequest arg);
  WidgetUpdateResponse onWidgetUpdate();
  void onWidgetStartTimer();
  static void setup(FlutterTimerApi api) {
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onExtendTime', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onExtendTime was null. Expected ExtendTimeResponse.');
          final ExtendTimeResponse input = ExtendTimeResponse.decode(message);
          api.onExtendTime(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onCountDown', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onCountDown was null. Expected CountDownRequest.');
          final CountDownRequest input = CountDownRequest.decode(message);
          api.onCountDown(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onContinueRequest', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onContinueRequest was null. Expected TimerRequest.');
          final TimerRequest input = TimerRequest.decode(message);
          api.onContinueRequest(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onPauseRequest', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onPauseRequest was null. Expected TimerRequest.');
          final TimerRequest input = TimerRequest.decode(message);
          api.onPauseRequest(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onCancelRequest', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onCancelRequest was null. Expected TimerRequest.');
          final TimerRequest input = TimerRequest.decode(message);
          api.onCancelRequest(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onRestartRequest', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onRestartRequest was null. Expected TimerRequest.');
          final TimerRequest input = TimerRequest.decode(message);
          api.onRestartRequest(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onOpen', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onOpen was null. Expected OpenRequest.');
          final OpenRequest input = OpenRequest.decode(message);
          api.onOpen(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onAlarm', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.FlutterTimerApi.onAlarm was null. Expected TimerRequest.');
          final TimerRequest input = TimerRequest.decode(message);
          api.onAlarm(input);
          return;
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onWidgetUpdate', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          // ignore message
          final WidgetUpdateResponse output = api.onWidgetUpdate();
          return output.encode();
        });
      }
    }
    {
      const BasicMessageChannel<Object> channel =
          BasicMessageChannel<Object>('dev.flutter.pigeon.FlutterTimerApi.onWidgetStartTimer', StandardMessageCodec());
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object message) async {
          // ignore message
          api.onWidgetStartTimer();
          return;
        });
      }
    }
  }
}

class HostTimerApi {
  Future<void> init(InitializationRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.init', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      // noop
    }
  }

  Future<NotificationResponse> showRunningNotification(RunningNotificationRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.showRunningNotification', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return NotificationResponse.decode(replyMap['result']);
    }
  }

  Future<NotificationResponse> showPausingNotification(TimeNotificationRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.showPausingNotification', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return NotificationResponse.decode(replyMap['result']);
    }
  }

  Future<NotificationResponse> showElapsedNotification(NotificationRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.showElapsedNotification', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return NotificationResponse.decode(replyMap['result']);
    }
  }

  Future<CancelResponse> cancelTimer(CancelRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.cancelTimer', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return CancelResponse.decode(replyMap['result']);
    }
  }

  Future<InstalledAppsResponse> getInstalledPlayerApps() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.getInstalledPlayerApps', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return InstalledAppsResponse.decode(replyMap['result']);
    }
  }

  Future<InstalledAppsResponse> getInstalledAlarmApps() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.getInstalledAlarmApps', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return InstalledAppsResponse.decode(replyMap['result']);
    }
  }

  Future<void> launchApp(LaunchAppRequest arg) async {
    final Object encoded = arg.encode();
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.launchApp', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(encoded) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      // noop
    }
  }

  Future<Package> dummyApp() async {
    const BasicMessageChannel<Object> channel =
        BasicMessageChannel<Object>('dev.flutter.pigeon.HostTimerApi.dummyApp', StandardMessageCodec());
    final Map<Object, Object> replyMap = await channel.send(null) as Map<Object, Object>;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object, Object> error = (replyMap['error'] as Map<Object, Object>);
      throw PlatformException(
        code: (error['code'] as String),
        message: error['message'] as String,
        details: error['details'],
      );
    } else {
      return Package.decode(replyMap['result']);
    }
  }
}
